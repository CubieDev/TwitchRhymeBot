
import sqlite3, logging, random
logger = logging.getLogger(__name__)

class Database:
    def __init__(self, channel):
        self.db_name = f"MarkovChain_{channel.replace('#', '').lower()}.db"

        sql = "SELECT name FROM sqlite_master WHERE type='table';"
        # Get a flattened list of tables
        table_list = [items[0] for items in self.execute(sql, fetch=True)]
        if "MarkovGrammar" not in table_list or "MarkovStart" not in table_list:
            raise Exception("The Database generated by my TwitchMarkovChain program needs to be present in the current directory for this bot to run.")

    def execute(self, sql, values=None, fetch=False):
        with sqlite3.connect(self.db_name) as conn:
            cur = conn.cursor()
            if values is None:
                cur.execute(sql)
            else:
                #print(sql, values)
                cur.execute(sql, values)
            conn.commit()
            if fetch:
                return cur.fetchall()
    
    def get_inputs(self, rhymes):
        if len(rhymes) > 1:
            return self.execute(f"SELECT input1, input2, output1 FROM MarkovGrammar WHERE output1 IN {tuple(rhymes)};", fetch=True)
        else:
            return self.execute(f"SELECT input1, input2, output1 FROM MarkovGrammar WHERE output1 = ?;", values=(list(rhymes)[0], ), fetch=True)
    
    def get_final_inputs(self, rhymes):
        # Modified version of get_inputs which only looks for cases where the sentence ends
        if len(rhymes) > 1:
            return self.execute(f"SELECT input1, input2 FROM MarkovGrammar WHERE input2 IN {tuple(rhymes)} AND output1 = '<END>';", fetch=True)
        else:
            return self.execute(f"SELECT input1, input2 FROM MarkovGrammar WHERE input2 = ? AND output1 = '<END>';", values=(list(rhymes)[0], ), fetch=True)
    
    def get_previous_double(self, input2, output1):
        return self.execute(f"SELECT input1 FROM MarkovGrammar WHERE input2 = ? AND output1 = ?;", values=(input2, output1), fetch=True)
    
    def get_previous_single(self, output1):
        return self.execute(f"SELECT input1 FROM MarkovGrammar WHERE output1 = ?;", values=(output1), fetch=True)
    
    def in_start(self, output1, output2):
        # Checks if output1 and output2 are the start of a sentence
        return len(self.execute(f"SELECT count FROM MarkovStart WHERE output1 = ? AND output2 = ?;", values=(output1, output2,), fetch=True)) > 0